# build:file

```js
  {
    "build:file": "node build/bin/iconInit.js & node build/bin/build-entry.js & node build/bin/i18n.js & node build/bin/version.js",
  }
```

补充下：
- `&` 符连接的是并行执行的任务，即同时的平行执行互不影响
- `&&` 符连接的是继发执行的任务，即只有前一个任务成功，才执行下一个任务

可以看到，该命令有四个并行任务，分别是：

- `node build/bin/iconInit.js`
- `node build/bin/build-entry.js`
- `node build/bin/i18n.js`
- `node build/bin/version.js`

让我们一个一个文件开始看，以下所有的文件都在 `build/bin/` 目录下。

## iconInit.js

```js
'use strict';

// CSS强大的预处理器
var postcss = require('postcss');
var fs = require('fs');
var path = require('path');
// 获取主题文件夹下的字体文件
var fontFile = fs.readFileSync(path.resolve(__dirname, '../../packages/theme-chalk/src/icon.scss'), 'utf8');
// 解析字体文件生成一个 css 虚拟语法树
// 这样我们后续就可以操作各种 css 规则了
// 这里是获取的所有 css 节点集合
var nodes = postcss.parse(fontFile).nodes;
// 保存字体类名
// 例如：['info','success','danger','warning']
var classList = [];

// 遍历 css 节点
nodes.forEach((node) => {
  // 获取 css 类选择器，比如：`.el-icon-info:before`
  var selector = node.selector || '';
  var reg = new RegExp(/\.el-icon-([^:]+):before/);
  var arr = selector.match(reg);

  if (arr && arr[1]) {
    // arr[1]: 'info'
    classList.push(arr[1]);
  }
});

// 最后是吧 `classList` 写入到 `examples/icon.json` 文件中
// fs.writeFile(file, data[,options],callback)
// data 参数可以是：String|Buffer|TypedArray|DataView
// 故，这里把数组转成了字符串形式进行存储
fs.writeFile(path.resolve(__dirname, '../../examples/icon.json'), JSON.stringify(classList), () => {});
```
这个文件的目的是把 `packages/theme-chalk/src/icon.scss` 文件中 icon 类名以数组的形式输出到 `examples/icon.json` 文件中。

比如， `icon.scss` 文件中的内容如下：

```css
.el-icon-info:before { content: "\e61a"; }
.el-icon-error:before { content: "\e62c"; }
.el-icon-success:before { content: "\e62d"; }
```

经过命令 `node build/bin/iconInit.js` 执行后， `icon.json` 文件内容变为：

```json
['info', 'error', 'success']
```
可以看下生成后的 [icon.json](https://github.com/ElemeFE/element/blob/dev/examples/icon.json)。 其中用到的插件：

- [postcss](https://www.npmjs.com/package/postcss) Scss 预处理器


## build-entry.js
其实 `src/index.js` 文件就是它生成的。一开始我在想，`src/index.js` 文件中的内容这么多一个个的写不麻烦吗？ 现在才知道是通过这条命令自动生成的。

内容有点多，我们看下重点：

```js
// 首先引入定义好的组件名及路径文件
var Components = require('../../components.json');
var fs = require('fs');
// JSON 模板
var render = require('json-templater/string');
// 文件名转大驼峰，
// 例如：component-name -> ComponentName
var uppercamelcase = require('uppercamelcase');
var path = require('path');
// Node 系统模块
// 操作系统相关的行末标志:
// `\n` 在 POSIX 系统上
// `\r\n` 在 Windows系统上
var endOfLine = require('os').EOL;
// 定义输出路径
var OUTPUT_PATH = path.join(__dirname, '../../src/index.js');
// 定义组件导入模板字符串
var IMPORT_TEMPLATE = 'import {{name}} from \'../packages/{{package}}/index.js\';';
// 定义安装组件模板字符串
var INSTALL_COMPONENT_TEMPLATE = '  {{name}}';
// 定义内容模板字符串
// 其中的 {{include}}、{{install}}、{{version}}、{{list}}
// 都是通过 render 方法动态填充的
var MAIN_TEMPLATE = `/* Automatically generated by './build/bin/build-entry.js' */
{{include}}
import locale from 'element-ui/src/locale';
import CollapseTransition from 'element-ui/src/transitions/collapse-transition';
const components = [
{{install}},
  CollapseTransition
];

...

module.exports = {
  version: '{{version}}',
  locale: locale.use,
  i18n: locale.i18n,
  install,
  CollapseTransition,
  Loading,
  {{list}}
};
module.exports.default = module.exports;
`;

// 删除 font 属性
// 其实里面并没有 font 这个 key，不知道为啥要执行这一步？
delete Components.font;

// 获取所有的 key
var ComponentNames = Object.keys(Components);

// 定义三个用来插入插槽的数组
var includeComponentTemplate = [];
var installTemplate = [];
var listTemplate = [];

// 遍历
ComponentNames.forEach(name => {
  // 把所有的 key 转成大驼峰形式
  var componentName = uppercamelcase(name);
  // 往数组里塞值
  includeComponentTemplate.push(render(IMPORT_TEMPLATE, {
    name: componentName,
    package: name
  }));
  
  // 排除下面是四个组件
  // 因为上面 MAIN_TEMPLATE 中已经安装到 Vue.prototype 上了
  if (['Loading', 'MessageBox', 'Notification', 'Message'].indexOf(componentName) === -1) {
    installTemplate.push(render(INSTALL_COMPONENT_TEMPLATE, {
      name: componentName,
      component: name
    }));
  }
  
  // 排除 Loading 组件
  // 因为上面 MAIN_TEMPLATE 中已经写死进去了
  if (componentName !== 'Loading') listTemplate.push(`  ${componentName}`);
});

// 替换插值模板，返回替换后的完成内容
// 即你现在在 src/index.js 中看到的样子
var template = render(MAIN_TEMPLATE, {
  include: includeComponentTemplate.join(endOfLine),
  install: installTemplate.join(',' + endOfLine),
  version: process.env.VERSION || require('../../package.json').version,
  list: listTemplate.join(',' + endOfLine)
});

// 最后写入到 src/index.js 中
fs.writeFileSync(OUTPUT_PATH, template);
// 已经 build 完啦
console.log('[build entry] DONE:', OUTPUT_PATH);
```

## i18n.js
这个文件的代码也不长：

```js
'use strict';

var fs = require('fs');
var path = require('path');
// Element官网国际化配置文件
var langConfig = require('../../examples/i18n/page.json');

// 遍历
langConfig.forEach(lang => {
  try {
    // 这里先获取文件夹，目的是检查该文件夹是否存在
    // 如果不存在则报错直接 catch 到创建新的
    fs.statSync(path.resolve(__dirname, `../../examples/pages/${ lang.lang }`));
  } catch (e) {
    // 没有这个文件夹则创建
    // mkdirSync 方法是 mkdir 的同步版，即：
    // 同步的创建一个文件夹，如果存在，则抛出异常
    // 所以，上面先判断下这个文件是否存在
    fs.mkdirSync(path.resolve(__dirname, `../../examples/pages/${ lang.lang }`));
  }
  
  // 遍历 pages 属性下的数据
  Object.keys(lang.pages).forEach(page => {
    // page值和 `examples/pages/template/` 下的模板名都是一一对应的
    // 找到模板路径
    var templatePath = path.resolve(__dirname, `../../examples/pages/template/${ page }.tpl`);
    // 输出路径，这里生成的是 .vue 文件
    var outputPath = path.resolve(__dirname, `../../examples/pages/${ lang.lang }/${ page }.vue`);
    // 同步读取模板文件内容
    var content = fs.readFileSync(templatePath, 'utf8');
    // 获取对应的 page 对象
    // page 对象下都是以数字为 key
    // 这样做是为了好替换模板中的数字
    var pairs = lang.pages[page];
    
    // 遍历
    Object.keys(pairs).forEach(key => {
      // key: 1,2,3,4,5...
      // 替换模板中的 `<%= ${ key } >` 占位符
      content = content.replace(new RegExp(`<%=\\s*${ key }\\s*>`, 'g'), pairs[key]);
    });
    
    // 写入到输出路径
    fs.writeFileSync(outputPath, content);
  });
});
```
这个文件的目的是根据国际化配置文件（`examples/i18n/page.json`）动态填充网站模板内容，并输出到对应的国际化目录下。

## version.js
顾名思义，定是管理网站版本号的。我们来看下代码：

```js
var fs = require('fs');
var path = require('path');
// 获取当前项目的最新版本
var version = process.env.VERSION || require('../../package.json').version;
// 这些是旧版本了
var content = { '1.4.13': '1.4', '2.0.11': '2.0', '2.1.0': '2.1', '2.2.2': '2.2', '2.3.9': '2.3' };
// 往数组里增加一个新本版
if (!content[version]) content[version] = '2.4';
// 同样的道理，把版本数组转成字符串保存到 `examples/version.json` 中
fs.writeFileSync(path.resolve(__dirname, '../../examples/versions.json'), JSON.stringify(content));
```

## 总结

至此，`build:file` 命名中的相关文件已经分析完啦。总结一下：

- `build/bin/iconInit.js` 负责生成网站字体图标列表，可以看[这里](http://element-cn.eleme.io/2.4/#/zh-CN/component/icon)
- `build/bin/build-entry.js` 负责生成 `src/index.js` 文件，为接下来的其他命令服务
- `build/bin/i18n.js` 负责网站国际化目录及页面的生成
- `build/bin/version.js` 负责网站版本号的生成